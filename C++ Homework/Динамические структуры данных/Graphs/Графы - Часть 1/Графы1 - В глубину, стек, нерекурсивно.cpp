/*
Данную программу выполнил Стеклянников Пётр Сергеевич из 151 группы. © Все права защищены.
*/

/*
Алгоритм обхода в глубину (DFS) без использования рекурсивных функций.

Алгоритм: 
Помечаем посещенную вершину (присваиваем соответствующему элементу массива значение 1) и помещаем ее в стек.
Пока стек не пуст, ищем смежную вершину для головы стека.
Если нашли, помещаем ее в стек, иначе извлекаем вершину из стека.
*/


#include<iostream>							//Подключение библиотеки ввода-вывода
#include<vector>							//Подключение библиотеки векторов
using namespace std;


struct stack {								//Стек описывается как struct следующим образом
	int inf;
	stack* next;
};
	
struct queue {								//очередь описывается как struct следующим образом
	int inf;
	queue* next;
};


void push(stack*& h, int x) {				//Функция добавления элемента в стек
	stack* r = new stack;					//Создаём новый элемент
	r->inf = x;								//Информационное поле inf = x
	r->next = h;							//Cледующим элементов является h
	h = r;									//Теперь r является головой
}

void push(queue*& h, queue*& t, int x) {	//вставка элемента в очередь
	queue* r = new queue;					//создаем новый элемент
	r->inf = x;								//информационное поле inf = x
	r->next = NULL;							//всегда последний(?)

	if (!h && !t) {							//если очередь пуста
		h = t = r;							//это и голова, и хвост
	}

	else {
		t->next = r;						//r - следующий для хвоста
		t = r;								//теперь r - хвост
	}
}


int pop(stack*& h) {						//Функция удаления элемента из стека (и возвращение его значения)
	int i = h->inf;							//Значение первого элемента
	stack* r = h;							//Указатель на голову стека
	h = h->next;							//Переносим указатель на следующий элемент
	delete r;								//Удаляем первый элемент
	return i;								//Возвращаем значение
}

int pop(queue*& h, queue*& t) {				//удаление элемента из очереди
	queue* r = h;							//создаем указатель на голову
	int i = h->inf;							//сохраняем значение головы
	h = h->next;							//сдвигаем указатель на следующий элемент

	if (!h)
		t = NULL;

	delete r;								//удаляем первый элемент
	return i;								//Возвращаем значение
}


int main() {								//Главная функция
	setlocale(LC_ALL, "RUS");
	cout << "Условие: \nДан граф, представленный в виде списка смежности. \nРеализация нерекурсивного обхода в глубину с помощью stack." << endl << endl;
	
	stack* head = NULL;

	int n, x;
	cout << "Размерность n массива a = ";
	cin >> n;

	cout << "Ввод списка смежности Gr: " << endl;
	int** Gr = new int*[n];
	int* Gr_sizes = new int[n];
	for (int i = 0; i < n; i++) {
		int Gr_i_size, elem;
		cout << "Размер i-контейнера, содержащего все вершины, смежные с данной: ";
		cin >> Gr_i_size;
		Gr[i] = new int[Gr_i_size];
		Gr_sizes[i] = Gr_i_size;
		cout << "Заполните контенер: ";
		for (int j = 0; j < Gr_i_size; j++) {
			cin >> elem;
			Gr[i][j] = elem;
		}
	}

	int* a = new int[n];
	for (int i = 0; i < n; i++) {
		a[i] = 0;
	}

	cout << "Выберите вершину x, с которой начнётся обход (0 <= x < n): ";
	cin >> x;
	a[x] = 1;
	push(head, x);
	cout << "a[" << x << "] = 1 Обозначена" << endl << endl;
	cout << "Найденная (введённая только что) вершина = " << x << endl;

	while (head) {
		bool fl = false;
		int x = head->inf;
		int y;
		for (int i = 0; i < Gr_sizes[x]; i++) {
			if (a[Gr[x][i]] == 0) {
				y = Gr[x][i];
				fl = true;
				break;
			}
		}

		if (fl == true) {
			a[y] = 1;
			push(head, y);
			cout << "Найденная вершина = " << y << endl;
		}

		else {
			pop(head);
		}
	}

	bool check = 0;
	for (int i = 0; i < n; i++) {
		if (a[i] == 0) {
			cout << "Осталась непосещенная вершина!" << endl;
			check = 1;
		}
	}
	if (check == 0) {
		cout << "Все вершины были найдены! \nКонец алгоритма." << endl << endl;
	}


	cout << endl << endl << "--------------------------------------------------------" << endl;





	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	cout << "Часть 2. Граф представлен в виде списка смежности. \nРеализация обхода в ширину, используя очередь." << endl << endl;
	
	queue* head_q = NULL;										
	queue* tail = NULL;

	for (int i = 0; i < n; i++) {							//Уже созданный массив а нужно только обнулить
		a[i] = 0;
	}

	int x_q;
	cout << "Выберите вершину x, с которой начнётся обход (0 <= x < n): ";
	cin >> x_q;
	a[x_q] = 1;
	push(head_q, tail, x);
	cout << "a[" << x << "] = 1 Обозначена" << endl << endl;
	cout << "Найденная (введённая только что) вершина = " << x << endl;

	while (head_q) {
		int x = pop(head_q, tail);
		for (int i = 0; i < Gr_sizes[x]; i++) {
			if (a[Gr[x][i]] == 0) {
				int y = Gr[x][i];
				a[y] = 1;
				push(head_q, tail, y);
				cout << "Найденная вершина = " << y << endl;
			}
		}
	}

	check = 0;
	for (int i = 0; i < n; i++) {
		if (a[i] == 0) {
			cout << "Осталась непосещенная вершина!" << endl;
			check = 1;
		}
	}
	if (check == 0) {
		cout << "Все вершины были найдены! \nКонец алгоритма." << endl << endl;
	}

	system("Pause");										//Пауза
	return 0;												//Конец программы
}


// 7 4 1 2 4 5 2 0 3 2 0 5 1 1 2 0 6 3 0 2 6 2 4 5

