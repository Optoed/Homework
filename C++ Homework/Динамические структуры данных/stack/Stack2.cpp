/*
Данную программу выполнил Стеклянников Пётр Сергеевич из 151 группы. © Все права защищены.
*/

/*
Пример 1.1. УСЛОВИЕ: 
Создать стек, содержащий целые числа.
После первого и последнего максимального числа вставить минимальное число. 
Порядок следования в результате должен совпадать с порядком следования ввода. 
Например, было 2 8 4 1 2 8 8 1 2 8 
Стало 2 8 1 4 1 2 8 8  1 2  8 1
*/


#include<iostream>						//Подключение библиотеки ввода-вывода
#include<limits.h>						//Библиотека лимитов
using namespace std;


struct stack {							//Стек описывается как struct следующим образом
	int inf;
	stack * next;
};


void push(stack * &h, int x) {			//Функция добавления элемента в стек
	stack * r = new stack;				//Создаём новый элемент
	r -> inf = x;						//Информационное поле inf = x
	r -> next = h;						//Cледующим элементов является h
	h = r;								//Теперь r является головой
}


int pop(stack * &h) {					//Функция удаления элемента из стека (и возвращение его значения)
	int i = h -> inf;					//Значение первого элемента
	stack * r = h;						//Указатель на голову стека
	h = h -> next;						//Переносим указатель на следующий элемент
	delete r;							//Удаляем первый элемент
	return i;							//Возвращаем значение
}


void reverse(stack * &h) {				//Функция "обращения" стека
	stack * head1 = NULL;				//Инициализация буферного стека

	while (h)							//Пока стек не пуст
		push(head1, pop(h));			//Переписываем из одного стека в другой

	h = head1;							//Переобозначаем указатели
}


stack * result(stack * &h) {			//Функция записи результата
	bool flag = 0;
	int max = INT_MIN;
	int min = INT_MAX;
	stack* h1 = h;
	int countmx = 0;

	while (h1) {						//Пока стек не пуст, ищем max и min
		int x = h1 -> inf;				
		h1 = h1 -> next;
		if (x > max) {
			max = x;
		}
		if (x < min)
			min = x;
	}

	cout << "max = " << max << " and min = " << min << endl;

	h1 = h;
	while (h1) {						//пока h1 не пуст, считаем количество max
		int x = h1->inf;
		h1 = h1->next;
		if (x == max) {
			countmx++;
		}
	}

	h1 = h;
	int count = 0;
	stack* res = NULL;
	h1 = NULL;

	while (h) {							//Пока стек h не пуст, после первого и последнего max вставляем min 
		
		int x = pop(h);
		push(res, x);

		if (x == max) {
			if (count == 0 || (countmx - 1 == count)) {
				push(res, min);
			}
			count++;
		}

	}

	cout << endl;

	reverse(res);						//Переворачиваем стек-результат res
	return res;							//Возвращаем стек-результат res
}




int main() {							//Главная функция
	setlocale(LC_ALL, "RUS");

	int n;								//Количество целых чисел
	cout << "n = ";
	cin >> n;							//Вводим количество целых чисел
	cout << endl;

	stack * head = NULL;				//Инициализация
	int x;
	for (int i = 0; i < n; i++) {		//Создаем стек
		cin >> x;						//Вводим число
		push(head, x);					//Заполняем стек
	}

	reverse(head);						//Переворачиваем стек, чтобы был тот порядок, в котором мы вводили числа

	stack * res = result(head);			//Результат (Стек, где мы ввели новый элемент после первого нечетного)
	cout << "Answer:" << endl;
	while (res)							//Пока res не станет пустым
		cout << pop(res) << " ";		//Выводим на экран элементы стека res функцией pop(...)
	cout << endl;
	
	system("Pause");					//Пауза
	return 0;							//Конец программы
}
